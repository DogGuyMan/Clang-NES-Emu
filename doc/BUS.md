
### 버스
* 주소 버스 (Address Bus) — "어디?"
  * CPU가 접근하고 싶은 메모리 위치를 지정합니다.
  NES CPU는 16비트 주소 버스이므로
  16개의 전선이 있고, 0부터 65535까지의 주소를 표현할 수 있습니다.
  이 전선에 값을 올리는 것은 CPU만 합니다. 단방향입니다.

* 데이터 버스 (Data Bus) — "뭘?"
  * 실제 데이터가 오가는 전선입니다.
  NES CPU는 8비트 데이터 버스이므로 8개의 전선, 한 번에 0~255 범위의 값을 전달합니다.
  이것은 양방향입니다. CPU가 쓸 때는 CPU→장치 방향, 읽을 때는 장치→CPU 방향으로 데이터가 흐릅니다.
  여기서 정리하신 것에 대해 하나 짚자면 — 데이터 버스 자체는 ADD, SUB, MUL 같은 연산을 하지 않습니다.
  데이터 버스는 단지 데이터를 운반할 뿐입니다. ALU 연산은 CPU 내부에서 일어나고, 데이터 버스는 그 연산에 사용될 값을 메모리에서 가져오거나 결과를 메모리에 돌려보내는 통로입니다.

* 제어 버스 (Control Bus) — "어떻게?"
  * 정리에서 빠진 것이 이것입니다.
  주소와 데이터만으로는 부족합니다.
  CPU가 `$4016` 주소에 값 1을 올렸다고 해도, 이것이 읽기인지 쓰기인지를 알려줘야 합니다.
  제어 버스의 전선들이 이 역할을 합니다.
  NES에서 중요한 제어 신호로는 R/W(Read/Write, 읽기면 1 쓰기면 0)가 있고, 이 외에도
  NMI, IRQ, RESET 같은 인터럽트 신호도 제어 버스에 해당합니다.

#### 하나의 메모리 읽기가 일어나는 과정
* LDA `$2002` (PPU 상태 레지스터 읽기)를 예로 들면:
  1. CPU가 주소 버스 16개 전선에 `$2002`를 올린다
  2. CPU가 제어 버스 R/W 신호를 "읽기"로 설정한다
  3. 주소 디코딩 로직이 `$2002`는 PPU 영역임을 판단, PPU 칩을 활성화한다
  4. PPU가 PPUSTATUS 값을 데이터 버스 8개 전선에 올린다
  5. CPU가 데이터 버스에서 값을 읽어 A 레지스터에 저장한다


#### 에뮬레이터에서
* bus_read(address)와 bus_write(address, data) 함수를 만들 때, 이 함수가 사실상 세 버스를 모두 추상화한 것입니다.
* address 파라미터가 주소 버스, data가 데이터 버스, read/write 함수 구분 자체가 제어 버스의 R/W 신호에 해당합니다.
