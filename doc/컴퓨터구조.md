## NES 에뮬레이터를 위한 기초 컴퓨터 구조

### 1. 비트, 바이트, 워드

컴퓨터가 다루는 정보의 최소 단위는 **비트(bit)** — 0 또는 1입니다.

비트 8개를 묶은 것이 **바이트(byte)**이고, 0~255(또는 부호 있으면 -128~127)의 값을 표현할 수 있습니다. NES의 CPU는 한 번에 8비트를 처리하므로 "8비트 프로세서"라고 부릅니다. 레지스터 하나가 담을 수 있는 값이 0~255라는 뜻이기도 합니다.

비트 표기에 익숙해지는 것이 중요합니다. 예를 들어 iNES 헤더의 Flags 6에서 "비트 0은 미러링, 비트 4–7은 매퍼 하위 니블"이라고 할 때, 이건 하나의 바이트를 8개의 개별 스위치로 쓰는 것입니다. C에서 비트를 추출하려면 AND 연산(`&`)과 시프트(`>>`)를 사용하게 됩니다.

**16진수(hexadecimal)** 표기도 필수입니다. `$FF`는 이진수 `11111111`, 십진수 255입니다. 주소와 바이트 값을 16진수로 표현하는 것이 NES 개발에서의 관례이고, 4비트가 16진수 한 자리에 정확히 대응하기 때문에 비트 패턴을 읽기 편합니다.

### 2. 레지스터

레지스터는 CPU 내부의 **초고속 저장 공간**입니다. 메모리에 접근하는 것보다 훨씬 빠르고, CPU가 실제로 연산을 수행하는 곳입니다.

6502에는 범용 레지스터가 극소수입니다:

**A (Accumulator)** — 산술/논리 연산의 주 대상. 덧셈, 뺄셈, AND, OR 등의 결과가 여기에 담깁니다.

**X, Y (Index)** — 주로 메모리 주소를 계산할 때 오프셋으로 사용합니다. 배열의 인덱스라고 생각하면 됩니다.

**SP (Stack Pointer)** — 스택의 현재 위치를 가리킵니다. 8비트이고, 스택은 $0100–$01FF에 고정되어 있어서 상위 바이트는 항상 $01입니다.

**PC (Program Counter)** — 다음에 실행할 명령어의 주소. 유일한 16비트 레지스터입니다. CPU는 매 사이클마다 PC가 가리키는 곳에서 명령어를 읽고, PC를 증가시키고, 명령어를 실행합니다.

**P (Status/Flags)** — 8비트이지만 하나의 "값"이 아니라 각 비트가 독립적인 플래그입니다. 연산 결과에 대한 메타 정보를 담습니다:

- **C (Carry)**: 덧셈에서 올림이 발생했거나 뺄셈에서 빌림이 없었을 때
- **Z (Zero)**: 결과가 0일 때
- **N (Negative)**: 결과의 최상위 비트가 1일 때 (2의 보수에서 음수)
- **V (Overflow)**: 부호 있는 연산에서 오버플로가 발생했을 때
- **I (Interrupt Disable)**: IRQ를 차단할지 여부
- **B, D**: NES에서는 D(Decimal)가 비활성화, B는 BRK 명령어 구분용

현대 CPU에도 같은 개념이 있지만 레지스터가 훨씬 많고 크기도 32/64비트입니다. 6502의 레지스터가 이렇게 적기 때문에 메모리 접근이 빈번하고, 그래서 다양한 어드레싱 모드가 발달한 겁니다.

### 3. 메모리와 주소 공간

**메모리**는 바이트의 배열입니다. 각 바이트에는 고유한 번호(주소)가 붙어 있고, CPU는 주소를 지정해서 특정 바이트를 읽거나 씁니다.

6502의 **주소 버스**는 16비트이므로 $0000부터 $FFFF까지, 총 65,536개(64KB)의 주소를 지정할 수 있습니다. 이것이 CPU가 바라볼 수 있는 세계의 전부입니다.

여기서 중요한 구분이 있습니다. **주소 공간(address space)**과 **물리적 메모리**는 다른 개념입니다.

CPU가 $2000번지를 읽는다고 해서 실제로 "메모리 칩의 8192번째 바이트"를 읽는 것이 아닙니다. $2000은 PPU 레지스터에 매핑되어 있어서, 그 읽기 요청은 PPU라는 완전히 다른 하드웨어에 전달됩니다. $8000을 읽으면 카트리지의 ROM 칩에서 데이터가 옵니다.

이것이 **메모리 맵드 I/O(Memory-Mapped I/O)**입니다. CPU 입장에서는 모든 것이 "메모리 읽기/쓰기"일 뿐이지만, 주소에 따라 실제로는 RAM, ROM, PPU, APU, 컨트롤러 등 서로 다른 하드웨어와 통신하는 겁니다. 에뮬레이터에서 "버스(Bus)"라는 모듈이 필요한 이유가 바로 이것입니다 — 주소를 받아서 올바른 장치로 라우팅하는 디코더 역할을 합니다.

### 4. 스택

스택은 **후입선출(LIFO)** 구조의 메모리 영역입니다. 6502에서는 $0100–$01FF의 256바이트가 스택으로 사용됩니다.

SP는 스택의 "꼭대기"를 가리키는데, 6502에서는 **아래로 자랍니다**. 초기값이 $FD(주소로는 $01FD)이고, 데이터를 push할 때마다 SP가 감소하고, pop하면 증가합니다.

스택이 필요한 이유는:

- **서브루틴 호출(JSR)**: 돌아올 주소(return address)를 스택에 저장
- **인터럽트 처리**: 현재 PC와 상태 레지스터를 스택에 저장
- **임시 값 저장**: PHA/PLA로 A 레지스터를 잠시 보관

함수 호출이 중첩될수록 스택이 쌓이고, 복귀할 때 역순으로 풀리는 구조입니다. 현대 프로그래밍의 콜 스택과 동일한 원리입니다.

### 5. 명령어 사이클과 클럭

CPU는 **클럭 신호**에 맞춰 동작합니다. NES의 CPU 클럭은 약 1.79MHz — 초당 약 179만 번 틱(tick)합니다.

하나의 명령어는 여러 클럭 사이클에 걸쳐 실행됩니다. 대략적인 과정은:

1. **Fetch**: PC가 가리키는 주소에서 opcode(명령어 코드) 1바이트를 읽음
2. **Decode**: 이 opcode가 어떤 명령어이고, 피연산자가 몇 바이트인지 판별
3. **Execute**: 필요한 추가 바이트를 읽고, 연산을 수행하고, 결과를 저장

단순한 명령어(NOP)는 2사이클, 복잡한 명령어는 6~7사이클이 걸립니다. 에뮬레이터에서 사이클을 정확히 세는 것이 중요한 이유는, PPU가 CPU 클럭의 3배 속도로 동작하기 때문입니다. CPU가 1사이클 진행할 때 PPU는 3사이클 진행해야 하고, 이 동기화가 틀리면 화면 출력 타이밍이 깨집니다.

### 6. 어드레싱 모드

"어드레싱 모드"는 명령어가 **피연산자의 위치를 어떻게 지정하는가**에 대한 것입니다. 6502가 13가지나 되는 어드레싱 모드를 가진 이유는 레지스터가 부족하기 때문입니다 — 다양한 방법으로 메모리에 접근할 수 있게 해서 레지스터 부족을 보상합니다.

핵심적인 것 몇 가지만 짚으면:

**Immediate** — 값 자체가 명령어 안에 들어있음. "A에 42를 넣어라"

**Zero Page** — 주소의 상위 바이트가 항상 $00. 즉 $0000–$00FF만 접근 가능하지만, 1바이트 주소만 쓰면 되므로 빠릅니다. 6502 프로그램에서 자주 쓰는 변수를 이 영역에 두는 이유입니다.

**Absolute** — 완전한 16비트 주소를 지정. 64KB 어디든 접근 가능하지만, 주소에 2바이트가 필요하므로 명령어가 길어집니다.

**Indexed (X, Y)** — 기준 주소에 X나 Y 레지스터 값을 더해서 최종 주소를 계산. 배열 순회에 사용됩니다. 여기서 **페이지 크로싱**이라는 개념이 나옵니다 — 기준 주소에 인덱스를 더했을 때 상위 바이트(페이지)가 바뀌면 추가 사이클이 소모됩니다.

**Indirect** — 주소가 가리키는 곳에 또 다른 주소가 들어있음. 포인터의 포인터 같은 개념입니다.

### 7. 엔디안(Endianness)

16비트 값을 메모리에 저장할 때 2바이트가 필요한데, 어떤 순서로 저장하느냐의 문제입니다.

6502는 **리틀 엔디안(little-endian)** — 하위 바이트가 낮은 주소에 먼저 옵니다.

주소 $8000에 $1234를 저장한다면:
- $8000에 $34 (하위 바이트)
- $8001에 $12 (상위 바이트)

iNES ROM 파서에서 16비트 값을 조립할 때 이 순서를 지켜야 합니다. 인터럽트 벡터를 읽을 때도, $FFFC에서 하위 바이트를, $FFFD에서 상위 바이트를 읽어서 합칩니다.

### 8. 인터럽트

CPU가 현재 실행 중인 코드를 **외부 신호에 의해 강제로 중단**하고, 미리 정해진 처리 루틴으로 점프하는 메커니즘입니다.

6502에는 세 가지가 있습니다:

**RESET** — 전원 투입 시. $FFFC–$FFFD에 저장된 주소에서 실행 시작.

**NMI (Non-Maskable Interrupt)** — 마스킹(차단) 불가능. NES에서는 PPU가 VBlank(화면 그리기 완료)에 진입할 때 발생합니다. 게임 로직의 대부분이 이 인터럽트 핸들러 안에서 동작합니다.

**IRQ (Interrupt Request)** — 마스킹 가능(I 플래그로 차단 가능). APU 타이머나 일부 매퍼(MMC3의 스캔라인 카운터 등)가 발생시킵니다.

인터럽트가 발생하면 CPU는 현재 PC와 상태 레지스터를 스택에 push하고, 해당 벡터 주소로 점프합니다. 처리가 끝나면 RTI 명령어로 스택에서 복원하고 원래 코드로 돌아갑니다.

### 9. 버스 (Bus)

버스는 CPU와 다른 장치들을 연결하는 **통신 경로**입니다. 세 종류가 있습니다:

**주소 버스(Address Bus)** — CPU가 "어디를" 읽거나 쓸지 지정 (6502: 16비트, 단방향)

**데이터 버스(Data Bus)** — 실제 데이터가 오가는 경로 (6502: 8비트, 양방향)

**제어 버스(Control Bus)** — 읽기/쓰기 구분, 클럭 신호 등

CPU가 메모리를 읽을 때의 과정은: 주소 버스에 주소를 올림 → 제어 버스로 "읽기" 신호를 보냄 → 해당 장치가 데이터 버스에 값을 올림 → CPU가 값을 가져감. 에뮬레이터에서 `bus_cpu_read(addr)`이 바로 이 과정의 소프트웨어적 표현입니다.

NES에는 CPU 버스와 PPU 버스가 **독립적으로** 존재합니다. PPU는 자체 16비트 주소 버스로 패턴 테이블과 네임테이블에 접근하고, CPU 버스와는 $2000–$2007의 레지스터를 통해서만 간접적으로 소통합니다.

### 10. DMA (Direct Memory Access)

CPU를 거치지 않고 메모리 간 데이터를 직접 전송하는 메커니즘입니다.

NES에서 $4014에 값을 쓰면 OAM DMA가 발동합니다. 지정된 페이지(256바이트)의 데이터가 PPU의 OAM(스프라이트 메모리)으로 한꺼번에 복사됩니다. 이 동안 CPU는 **513 또는 514 사이클 동안 정지(stall)**합니다. 매 프레임 스프라이트 데이터를 전송할 때 사용되며, CPU가 1바이트씩 직접 전송하는 것보다 효율적입니다.

---

이 열 가지 개념이 NES 에뮬레이터의 거의 모든 모듈에 걸쳐 반복적으로 나타납니다. ROM 파서에서는 바이트 조작과 엔디안, CPU에서는 레지스터/어드레싱 모드/인터럽트/사이클, 버스에서는 메모리 맵과 주소 디코딩, PPU와의 연동에서는 클럭 동기화와 DMA가 핵심이 됩니다. 특정 개념을 더 깊이 파고 싶은 부분이 있으면 말해주세요.
