# 6502 명령어 레퍼런스

> 원본: https://www.nesdev.org/wiki/Instruction_reference

---

## 공식 6502 명령어 목록

|     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| ADC | AND | ASL | BCC | BCS | BEQ | BIT | BMI | BNE | BPL | BRK | BVC | BVS | CLC |
| CLD | CLI | CLV | CMP | CPX | CPY | DEC | DEX | DEY | EOR | INC | INX | INY | JMP |
| JSR | LDA | LDX | LDY | LSR | NOP | ORA | PHA | PHP | PLA | PLP | ROL | ROR | RTI |
| RTS | SBC | SEC | SED | SEI | STA | STX | STY | TAX | TAY | TSX | TXA | TXS | TYA |

## 유형별 공식 명령어

| 유형             | 명령어 |     |     |     |     |     |           |
| ---------------- | ------ | --- | --- | --- | --- | --- | --------- |
| 접근(Access)     | LDA    | STA | LDX | STX | LDY | STY |           |
| 전송(Transfer)   | TAX    | TXA | TAY | TYA |     |     |           |
| 산술(Arithmetic) | ADC    | SBC | INC | DEC | INX | DEX | INY / DEY |
| 시프트(Shift)    | ASL    | LSR | ROL | ROR |     |     |           |
| 비트(Bitwise)    | AND    | ORA | EOR | BIT |     |     |           |
| 비교(Compare)    | CMP    | CPX | CPY |     |     |     |           |
| 분기(Branch)     | BCC    | BCS | BEQ | BNE | BPL | BMI | BVC / BVS |
| 점프(Jump)       | JMP    | JSR | RTS | BRK | RTI |     |           |
| 스택(Stack)      | PHA    | PLA | PHP | PLP | TXS | TSX |           |
| 플래그(Flags)    | CLC    | SEC | CLI | SEI | CLD | SED | CLV       |
| 기타(Other)      | NOP    |     |     |     |     |     |           |

---

## 공식 명령어 상세

---

### ADC - 캐리 포함 덧셈 (Add with Carry)

`A = A + memory + C`

ADC는 캐리 플래그와 메모리 값을 누산기에 더한다. 그 후 캐리 플래그는 비트 7에서 나온 캐리 값으로 설정되어, 1바이트보다 큰 값을 캐리를 다음 바이트 덧셈으로 올려 보내며 합산할 수 있게 한다. 이것은 부호 없는 오버플로우로도 생각할 수 있다. 첫 바이트를 더하기 전에 CLC로 캐리를 클리어하여 알려진 상태로 만드는 것이 일반적이며, 이로써 하나 차이 오류를 방지한다. 오버플로우 플래그는 부호 있는 오버플로우 또는 언더플로우가 발생했는지를 나타낸다. 이는 두 입력이 모두 양수인데 결과가 음수이거나, 두 입력이 모두 음수인데 결과가 양수일 때 발생한다.

| 플래그         | 새 값                                  | 비고                                                                                       |
| -------------- | -------------------------------------- | ------------------------------------------------------------------------------------------ |
| C - 캐리       | result > $FF                           | 결과가 $FF를 넘어서 랩어라운드되면 부호 없는 오버플로우 발생                               |
| Z - 제로       | result == 0                            |                                                                                            |
| V - 오버플로우 | (result ^ A) & (result ^ memory) & $80 | 결과의 부호가 A와 memory 둘 다의 부호와 다르면, 부호 있는 오버플로우(또는 언더플로우) 발생 |
| N - 네거티브   | result 비트 7                          |                                                                                            |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $69    | 2      | 2                      |
| Zero Page     | $65    | 2      | 3                      |
| Zero Page,X   | $75    | 2      | 4                      |
| Absolute      | $6D    | 3      | 4                      |
| Absolute,X    | $7D    | 3      | 4 (페이지 크로싱 시 5) |
| Absolute,Y    | $79    | 3      | 4 (페이지 크로싱 시 5) |
| (Indirect,X)  | $61    | 2      | 6                      |
| (Indirect),Y  | $71    | 2      | 5 (페이지 크로싱 시 6) |

참고: SBC, CLC

---

### AND - 비트 AND (Bitwise AND)

`A = A & memory`

메모리 값과 누산기를 비트 단위로 AND한다. 두 입력 비트가 모두 1이면 결과 비트는 1이다. 그렇지 않으면 0이다.

| A   | memory | result |
| --- | ------ | ------ |
| 0   | 0      | 0      |
| 0   | 1      | 0      |
| 1   | 0      | 0      |
| 1   | 1      | 1      |

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $29    | 2      | 2                      |
| Zero Page     | $25    | 2      | 3                      |
| Zero Page,X   | $35    | 2      | 4                      |
| Absolute      | $2D    | 3      | 4                      |
| Absolute,X    | $3D    | 3      | 4 (페이지 크로싱 시 5) |
| Absolute,Y    | $39    | 3      | 4 (페이지 크로싱 시 5) |
| (Indirect,X)  | $21    | 2      | 6                      |
| (Indirect),Y  | $31    | 2      | 5 (페이지 크로싱 시 6) |

참고: ORA, EOR

---

### ASL - 산술 좌측 시프트 (Arithmetic Shift Left)

`value = value << 1`, 시각적으로: `C <- [76543210] <- 0`

ASL은 메모리 값 또는 누산기의 모든 비트를 한 위치 왼쪽으로 이동시켜, 각 비트의 값을 다음 비트로 옮긴다. 비트 7은 캐리 플래그로 이동되고, 0이 비트 0으로 들어간다. 이것은 부호 없는 값에 2를 곱하는 것과 동일하며, 캐리가 오버플로우를 나타낸다.

이것은 **읽기-수정-쓰기(read-modify-write)** 명령어로, 메모리에서 동작하는 어드레싱 모드에서는 수정된 값을 쓰기 전에 먼저 원래 값을 메모리에 다시 쓴다. 이 추가 쓰기는 하드웨어 레지스터를 대상으로 할 때 중요할 수 있다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| C - 캐리     | value 비트 7  |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Accumulator   | $0A    | 1      | 2      |
| Zero Page     | $06    | 2      | 5      |
| Zero Page,X   | $16    | 2      | 6      |
| Absolute      | $0E    | 3      | 6      |
| Absolute,X    | $1E    | 3      | 7      |

참고: LSR, ROL, ROR

---

### BCC - 캐리 클리어 시 분기 (Branch if Carry Clear)

`PC = PC + 2 + memory (signed)`

캐리 플래그가 클리어이면, BCC는 상대 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다. 오프셋은 부호 있으며, 분기 명령어 *다음* 첫 번째 바이트를 기준으로 [-128, 127] 범위이다. 이보다 먼 곳으로 분기하려면 JMP 명령어를 사용하고, 캐리가 세트일 때 BCS로 그 JMP를 건너뛰어야 한다.

캐리 플래그는 문맥에 따라 다른 의미를 가진다. BCC는 비교 후에 레지스터가 메모리 값보다 작으면 분기하는 데 사용할 수 있어서, BLT(Branch if Less Than)로도 불린다. SBC 후에 부호 없는 값이 언더플로우했으면 분기하거나, ADC 후에 오버플로우하지 *않았으면* 분기하는 데도 사용할 수 있다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $90    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BCS, JMP

---

### BCS - 캐리 세트 시 분기 (Branch if Carry Set)

`PC = PC + 2 + memory (signed)`

캐리 플래그가 세트이면, BCS는 분기 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다. 오프셋은 부호 있으며, 분기 명령어 *다음* 첫 번째 바이트를 기준으로 [-128, 127] 범위이다.

BCS는 비교 후에 레지스터가 메모리 값보다 크거나 같으면 분기하는 데 사용할 수 있어서, BGE(Branch if Greater Than or Equal)로도 불린다. ADC 후에 부호 없는 값이 오버플로우했으면 분기하거나, SBC 후에 언더플로우하지 *않았으면* 분기하는 데도 사용할 수 있다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $B0    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BCC, JMP

---

### BEQ - 같으면 분기 (Branch if Equal)

`PC = PC + 2 + memory (signed)`

제로 플래그가 세트이면, BEQ는 분기 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다. 비교 명령어는 이 플래그를 사용하여 비교 값이 같은지를 나타낸다. A, X, 또는 Y를 변경하는 모든 명령어도 레지스터가 0이 되는지에 따라 암시적으로 제로 플래그를 세트하거나 클리어한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $F0    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BNE, JMP

---

### BIT - 비트 테스트 (Bit Test)

`A & memory`

BIT는 플래그를 수정하지만 메모리나 레지스터를 변경하지는 않는다. 제로 플래그는 누산기 AND 메모리 값의 결과에 따라 세트되어, 사실상 비트마스크를 적용하고 어떤 비트가 세트되어 있는지 확인한다. 메모리 값의 비트 7과 비트 6은 네거티브와 오버플로우 플래그에 직접 로드되어, A에 마스크를 로드하지 않고도 쉽게 확인할 수 있다.

BIT는 CPU 플래그만 변경하므로, CPU 레지스터를 훼손하지 않고 하드웨어 레지스터의 읽기 사이드 이펙트를 트리거하거나, 3사이클 NOP로 사이클을 소비하는 데 사용되기도 한다. 고급 트릭으로, 오퍼랜드 안에 1~2바이트 명령어를 숨겨 직접 점프해 왔을 때만 실행되도록 하여 두 코드 경로를 교차시키는 데 간혹 사용된다. 그러나 오퍼랜드의 명령어가 읽을 주소로 취급되므로, 하드웨어 레지스터를 읽을 경우 사이드 이펙트를 트리거할 위험이 있다.

| 플래그         | 새 값         |
| -------------- | ------------- |
| Z - 제로       | result == 0   |
| V - 오버플로우 | memory 비트 6 |
| N - 네거티브   | memory 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Zero Page     | $24    | 2      | 3      |
| Absolute      | $2C    | 3      | 4      |

참고: AND

---

### BMI - 마이너스 시 분기 (Branch if Minus)

`PC = PC + 2 + memory (signed)`

네거티브 플래그가 세트이면, BMI는 분기 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다. A, X, 또는 Y를 변경하는 모든 명령어는 비트 7(부호 비트)에 따라 암시적으로 네거티브 플래그를 세트하거나 클리어한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $30    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BPL, JMP

---

### BNE - 같지 않으면 분기 (Branch if Not Equal)

`PC = PC + 2 + memory (signed)`

제로 플래그가 클리어이면, BNE는 분기 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다. 비교 명령어는 이 플래그를 사용하여 비교 값이 같은지를 나타낸다. A, X, 또는 Y를 변경하는 모든 명령어도 레지스터가 0이 되는지에 따라 암시적으로 제로 플래그를 세트하거나 클리어한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $D0    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BEQ, JMP

---

### BPL - 플러스 시 분기 (Branch if Plus)

`PC = PC + 2 + memory (signed)`

네거티브 플래그가 클리어이면, BPL은 분기 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다. A, X, 또는 Y를 변경하는 모든 명령어는 비트 7(부호 비트)에 따라 암시적으로 네거티브 플래그를 세트하거나 클리어한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $10    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BMI, JMP

---

### BRK - 브레이크 / 소프트웨어 IRQ (Break)

```
PC + 2 상위 바이트를 스택에 푸시
PC + 2 하위 바이트를 스택에 푸시
NV11DIZC 플래그를 스택에 푸시
PC = ($FFFE)
```

BRK는 인터럽트 요청(IRQ)을 트리거한다. IRQ는 보통 외부 하드웨어에 의해 트리거되며, BRK는 소프트웨어에서 이를 수행하는 유일한 방법이다. 일반적인 IRQ처럼, 현재 프로그램 카운터와 프로세서 플래그를 스택에 푸시하고, 인터럽트 비활성 플래그를 세트하고, IRQ 핸들러로 점프한다. 일반적인 IRQ와 달리, 스택에 푸시되는 플래그 바이트에 브레이크 플래그를 세트하고(PHP처럼), 인터럽트 비활성 플래그가 세트되어 있어도 인터럽트를 트리거한다. 주목할 점은, 스택에 푸시되는 반환 주소가 BRK opcode 다음 바이트를 건너뛴다는 것이다. 이런 이유로 BRK는 사용하지 않는 이미디에이트를 가진 2바이트 명령어로 간주되기도 한다.

불행히도, 6502 버그로 인해 BRK IRQ가 동시에 발생하는 NMI에 의해 오버라이드될 수 있다. 이 경우 NMI 핸들러만 호출되고 IRQ 핸들러는 건너뛰어진다. 그러나 스택에 푸시된 플래그 바이트에 브레이크 플래그가 여전히 세트되어 있으므로, NMI 핸들러가 (느리긴 하지만) 이 플래그를 확인하여 이 상황을 감지할 수 있다.

BRK는 값 $00을 사용하므로, 프로그래밍 가능한 ROM의 모든 바이트를 BRK 명령어로 덮어써서 IRQ 핸들러로 실행을 보낼 수 있다. NES 게임 맥락에서 BRK는 크래시 핸들러로 가장 유용한 경우가 많으며, 미사용 프로그램 공간을 $00으로 채우고 IRQ 핸들러가 디버깅 정보를 표시하거나 크래시를 깔끔하게 처리한다.

| 플래그              | 새 값    | 비고                                                                                         |
| ------------------- | -------- | -------------------------------------------------------------------------------------------- |
| I - 인터럽트 비활성 | 1        | 이전 플래그가 스택에 푸시된 후 1로 설정된다. 이 플래그 변경 효과는 지연되지 *않는다*.        |
| B - 브레이크        | 1로 푸시 | 이 플래그는 스택에 푸시되는 플래그 바이트에만 존재하며, CPU의 실제 상태로는 존재하지 않는다. |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 | 비고                                                              |
| ------------- | ------ | ------ | ------ | ----------------------------------------------------------------- |
| Implied       | $00    | 1      | 7      | BRK는 1바이트만 사용하지만, 반환 주소는 다음 바이트를 건너뛴다.   |
| #Immediate    | $00    | 2      | 7      | BRK가 다음 바이트를 건너뛰므로, 2바이트 명령어로 간주되기도 한다. |

참고: RTI, PHP

---

### BVC - 오버플로우 클리어 시 분기 (Branch if Overflow Clear)

`PC = PC + 2 + memory (signed)`

오버플로우 플래그가 클리어이면, BVC는 분기 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다. 제로, 네거티브, 심지어 캐리와 달리, 오버플로우를 수정하는 명령어는 매우 적다. BIT 명령어와 함께 특히 하드웨어 레지스터 폴링에 가장 자주 사용된다. ADC와 SBC에서의 부호 있는 오버플로우에도 간혹 사용된다. 표준 6502 칩은 외부 장치가 핀을 사용하여 오버플로우를 세트할 수 있게 하지만, NES의 2A03에는 이것이 존재하지 않는다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $50    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BVS, JMP

---

### BVS - 오버플로우 세트 시 분기 (Branch if Overflow Set)

`PC = PC + 2 + memory (signed)`

오버플로우 플래그가 세트이면, BVS는 분기 오프셋을 프로그램 카운터에 더하여 가까운 위치로 분기한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클                             |
| ------------- | ------ | ------ | ---------------------------------- |
| Relative      | $70    | 2      | 2 (분기 시 3, 페이지 크로싱 시 4)* |

참고: BVC, JMP

---

### CLC - 캐리 클리어 (Clear Carry)

`C = 0`

CLC는 캐리 플래그를 클리어한다. 특히 ADC로 값의 하위 바이트를 더하기 전에 추가 1이 더해지는 것을 방지하기 위해 수행된다.

| 플래그   | 새 값 |
| -------- | ----- |
| C - 캐리 | 0     |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $18    | 1      | 2      |

참고: SEC

---

### CLD - 십진 모드 클리어 (Clear Decimal)

`D = 0`

CLD는 십진 플래그를 클리어한다. 십진 플래그는 보통 BCD(이진화 십진) 모드를 활성화하는지를 제어하지만, 이 모드는 NES의 2A03 CPU에서 영구적으로 비활성화되어 있다. 그러나 플래그 자체는 여전히 동작하며 상태를 저장하는 데 사용할 수 있다.

| 플래그      | 새 값 |
| ----------- | ----- |
| D - Decimal | 0     |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $D8    | 1      | 2      |

참고: SED

---

### CLI - 인터럽트 비활성 클리어 (Clear Interrupt Disable)

`I = 0`

CLI는 인터럽트 비활성 플래그를 클리어하여, CPU가 하드웨어 IRQ를 처리할 수 있게 한다. 이 플래그 변경 효과는 **1 명령어 지연**된다. 플래그가 IRQ 폴링 이후에 변경되기 때문에, 대기 중인 IRQ가 감지되어 서비스되기 전에 다음 명령어가 실행될 수 있다. 이 플래그는 NMI에는 영향을 미치지 않으며, NMI는 ("마스크 불가능"이라는 이름이 시사하듯) CPU에 의해 무시될 수 없다.

| 플래그              | 새 값 | 비고                                     |
| ------------------- | ----- | ---------------------------------------- |
| I - 인터럽트 비활성 | 0     | 이 플래그 변경 효과는 1 명령어 지연된다. |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $58    | 1      | 2      |

참고: SEI

---

### CLV - 오버플로우 클리어 (Clear Overflow)

`V = 0`

CLV는 오버플로우 플래그를 클리어한다. 대응하는 SEV 명령어는 없다. 대신 오버플로우 설정은 6502 CPU에서 외부 하드웨어가 제어하는 핀으로 노출되며, NES의 2A03 CPU에서는 전혀 노출되지 않는다.

| 플래그         | 새 값 |
| -------------- | ----- |
| V - 오버플로우 | 0     |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $B8    | 1      | 2      |

---

### CMP - A 비교 (Compare A)

`A - memory`

CMP는 A를 메모리 값과 비교하여 플래그를 적절히 설정하되, 레지스터는 수정하지 않는다. 비교는 뺄셈으로 구현되며, 빌려 가기(borrow)가 없으면 캐리를 세트하고, 결과가 0이면 제로를 세트하고, 결과가 음수이면 네거티브를 세트한다. 그러나 캐리와 제로는 부등식으로 기억하는 것이 가장 쉬운 경우가 많다.

비교는 오버플로우에 영향을 미치지 *않는다*는 점에 유의한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| C - 캐리     | A >= memory   |
| Z - 제로     | A == memory   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $C9    | 2      | 2                      |
| Zero Page     | $C5    | 2      | 3                      |
| Zero Page,X   | $D5    | 2      | 4                      |
| Absolute      | $CD    | 3      | 4                      |
| Absolute,X    | $DD    | 3      | 4 (페이지 크로싱 시 5) |
| Absolute,Y    | $D9    | 3      | 4 (페이지 크로싱 시 5) |
| (Indirect,X)  | $C1    | 2      | 6                      |
| (Indirect),Y  | $D1    | 2      | 5 (페이지 크로싱 시 6) |

참고: CPX, CPY

---

### CPX - X 비교 (Compare X)

`X - memory`

CPX는 X를 메모리 값과 비교하여 플래그를 적절히 설정하되, 레지스터는 수정하지 않는다. 비교는 뺄셈으로 구현된다. 비교는 오버플로우에 영향을 미치지 *않는다*.

| 플래그       | 새 값         |
| ------------ | ------------- |
| C - 캐리     | X >= memory   |
| Z - 제로     | X == memory   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| #Immediate    | $E0    | 2      | 2      |
| Zero Page     | $E4    | 2      | 3      |
| Absolute      | $EC    | 3      | 4      |

참고: CMP, CPY

---

### CPY - Y 비교 (Compare Y)

`Y - memory`

CPY는 Y를 메모리 값과 비교하여 플래그를 적절히 설정하되, 레지스터는 수정하지 않는다. 비교는 뺄셈으로 구현된다. 비교는 오버플로우에 영향을 미치지 *않는다*.

| 플래그       | 새 값         |
| ------------ | ------------- |
| C - 캐리     | Y >= memory   |
| Z - 제로     | Y == memory   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| #Immediate    | $C0    | 2      | 2      |
| Zero Page     | $C4    | 2      | 3      |
| Absolute      | $CC    | 3      | 4      |

참고: CMP, CPX

---

### DEC - 메모리 감소 (Decrement Memory)

`memory = memory - 1`

DEC는 메모리 위치에서 1을 뺀다. 주목할 점으로, 이 명령어의 누산기 버전은 없으며, 대신 ADC나 SBC를 사용해야 한다.

이것은 **읽기-수정-쓰기** 명령어로, 수정된 값 전에 먼저 원래 값을 메모리에 다시 쓴다. 이 추가 쓰기는 하드웨어 레지스터를 대상으로 할 때 중요할 수 있다.

감소는 캐리와 오버플로우에 영향을 미치지 *않는다*는 점에 유의한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Zero Page     | $C6    | 2      | 5      |
| Zero Page,X   | $D6    | 2      | 6      |
| Absolute      | $CE    | 3      | 6      |
| Absolute,X    | $DE    | 3      | 7      |

참고: INC, ADC, SBC

---

### DEX - X 감소 (Decrement X)

`X = X - 1`

DEX는 X 레지스터에서 1을 뺀다. 캐리와 오버플로우에 영향을 미치지 *않는다*.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $CA    | 1      | 2      |

참고: INX

---

### DEY - Y 감소 (Decrement Y)

`Y = Y - 1`

DEY는 Y 레지스터에서 1을 뺀다. 캐리와 오버플로우에 영향을 미치지 *않는다*.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $88    | 1      | 2      |

참고: INY

---

### EOR - 배타적 OR (Bitwise Exclusive OR)

`A = A ^ memory`

EOR은 메모리 값과 누산기를 비트 단위로 배타적-OR한다. 입력 비트가 다르면 결과 비트는 1이다. 같으면 0이다. 이 연산은 XOR로도 알려져 있다.

6502에는 비트 NOT 명령어가 없지만, EOR을 값 $FF와 사용하면 같은 동작을 하여 다른 값의 모든 비트를 반전시킨다. 사실 EOR은 비트마스크가 있는 NOT으로 생각할 수 있다. 한 값의 1 비트 모두가 다른 값의 대응 비트를 반전시키는 효과가 있고, 0 비트는 아무것도 하지 않는다.

| A   | memory | result |
| --- | ------ | ------ |
| 0   | 0      | 0      |
| 0   | 1      | 1      |
| 1   | 0      | 1      |
| 1   | 1      | 0      |

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $49    | 2      | 2                      |
| Zero Page     | $45    | 2      | 3                      |
| Zero Page,X   | $55    | 2      | 4                      |
| Absolute      | $4D    | 3      | 4                      |
| Absolute,X    | $5D    | 3      | 4 (페이지 크로싱 시 5) |
| Absolute,Y    | $59    | 3      | 4 (페이지 크로싱 시 5) |
| (Indirect,X)  | $41    | 2      | 6                      |
| (Indirect),Y  | $51    | 2      | 5 (페이지 크로싱 시 6) |

참고: AND, ORA

---

### INC - 메모리 증가 (Increment Memory)

`memory = memory + 1`

INC는 메모리 위치에 1을 더한다. 이 명령어의 누산기 버전은 없으며, 대신 ADC나 SBC를 사용해야 한다.

이것은 **읽기-수정-쓰기** 명령어로, 수정된 값 전에 먼저 원래 값을 메모리에 다시 쓴다. 증가는 캐리와 오버플로우에 영향을 미치지 *않는다*.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Zero Page     | $E6    | 2      | 5      |
| Zero Page,X   | $F6    | 2      | 6      |
| Absolute      | $EE    | 3      | 6      |
| Absolute,X    | $FE    | 3      | 7      |

참고: DEC, ADC, SBC

---

### INX - X 증가 (Increment X)

`X = X + 1`

INX는 X 레지스터에 1을 더한다. 캐리와 오버플로우에 영향을 미치지 *않는다*.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $E8    | 1      | 2      |

참고: DEX

---

### INY - Y 증가 (Increment Y)

`Y = Y + 1`

INY는 Y 레지스터에 1을 더한다. 캐리와 오버플로우에 영향을 미치지 *않는다*.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $C8    | 1      | 2      |

참고: DEY

---

### JMP - 점프 (Jump)

`PC = memory`

JMP는 프로그램 카운터를 새 값으로 설정하여 새 위치에서 코드를 실행할 수 있게 한다. 해당 위치에서 돌아올 수 있기를 원한다면, 보통 JSR을 대신 사용해야 한다.

간접 어드레싱 모드는 오퍼랜드를 포인터로 사용하여, 지정된 주소에서 새로운 2바이트 프로그램 카운터 값을 가져온다. 불행히도 CPU 버그 때문에, 이 2바이트 변수의 주소가 $FF로 끝나 페이지를 넘어가면, CPU가 두 번째 바이트를 읽을 때 페이지를 증가시키지 못하여 잘못된 주소를 읽는다. 예를 들어, JMP ($03FF)는 $03FF와 $0400 대신 *$0300*을 읽는다. 이 변수가 페이지를 넘지 않도록 주의해야 한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Absolute      | $4C    | 3      | 3      |
| (Indirect)    | $6C    | 3      | 5      |

참고: JSR

---

### JSR - 서브루틴 점프 (Jump to Subroutine)

```
PC + 2 상위 바이트를 스택에 푸시
PC + 2 하위 바이트를 스택에 푸시
PC = memory
```

JSR은 현재 프로그램 카운터를 스택에 푸시하고 프로그램 카운터를 새 값으로 설정한다. 이로써 코드가 함수를 호출하고 RTS로 JSR 다음 명령어로 돌아올 수 있다.

주목할 점으로, 스택의 반환 주소는 다음 명령어 시작 1바이트 전을 가리키며, 명령어를 직접 가리키지 않는다. 이는 RTS가 다음 명령어를 페치하기 전에 프로그램 카운터를 증가시키기 때문이다. 이것은 인터럽트에 의해 푸시되고 RTI가 사용하는 반환 주소와 다르며, 인터럽트의 반환 주소는 다음 명령어를 직접 가리킨다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Absolute      | $20    | 3      | 6      |

참고: RTS, JMP, RTI

---

### LDA - A 로드 (Load A)

`A = memory`

LDA는 메모리 값을 누산기에 로드한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $A9    | 2      | 2                      |
| Zero Page     | $A5    | 2      | 3                      |
| Zero Page,X   | $B5    | 2      | 4                      |
| Absolute      | $AD    | 3      | 4                      |
| Absolute,X    | $BD    | 3      | 4 (페이지 크로싱 시 5) |
| Absolute,Y    | $B9    | 3      | 4 (페이지 크로싱 시 5) |
| (Indirect,X)  | $A1    | 2      | 6                      |
| (Indirect),Y  | $B1    | 2      | 5 (페이지 크로싱 시 6) |

참고: STA

---

### LDX - X 로드 (Load X)

`X = memory`

LDX는 메모리 값을 X 레지스터에 로드한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $A2    | 2      | 2                      |
| Zero Page     | $A6    | 2      | 3                      |
| Zero Page,Y   | $B6    | 2      | 4                      |
| Absolute      | $AE    | 3      | 4                      |
| Absolute,Y    | $BE    | 3      | 4 (페이지 크로싱 시 5) |

참고: STX

---

### LDY - Y 로드 (Load Y)

`Y = memory`

LDY는 메모리 값을 Y 레지스터에 로드한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $A0    | 2      | 2                      |
| Zero Page     | $A4    | 2      | 3                      |
| Zero Page,X   | $B4    | 2      | 4                      |
| Absolute      | $AC    | 3      | 4                      |
| Absolute,X    | $BC    | 3      | 4 (페이지 크로싱 시 5) |

참고: STY
### LSR - 논리 우측 시프트 (Logical Shift Right)

`value = value >> 1`, 시각적으로: `0 -> [76543210] -> C`

LSR은 메모리 값 또는 누산기의 모든 비트를 한 위치 오른쪽으로 이동시켜, 각 비트의 값을 다음 비트로 옮긴다. 0이 비트 7로 들어가고, 비트 0은 캐리 플래그로 이동된다. 이것은 부호 없는 값을 2로 나누고 내림하는 것과 동일하며, 나머지가 캐리에 들어간다.

이것은 **읽기-수정-쓰기** 명령어로, 메모리에서 동작하는 어드레싱 모드에서는 수정된 값 전에 먼저 원래 값을 메모리에 다시 쓴다.

| 플래그       | 새 값        |
| ------------ | ------------ |
| C - 캐리     | value 비트 0 |
| Z - 제로     | result == 0  |
| N - 네거티브 | 0            |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Accumulator   | $4A    | 1      | 2      |
| Zero Page     | $46    | 2      | 5      |
| Zero Page,X   | $56    | 2      | 6      |
| Absolute      | $4E    | 3      | 6      |
| Absolute,X    | $5E    | 3      | 7      |

참고: ASL, ROL, ROR

---

### NOP - 무연산 (No Operation)

NOP는 아무 효과가 없으며, 단지 공간과 CPU 사이클을 소비한다. 이 명령어는 타이밍 코드를 작성할 때 원하는 시간만큼 지연하거나, 무언가가 페이지를 넘거나 넘지 않도록 패딩하거나, 바이너리에서 코드를 비활성화하는 데 유용할 수 있다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $EA    | 1      | 2      |

---

### ORA - 비트 OR (Bitwise OR)

`A = A | memory`

ORA는 메모리 값과 누산기를 비트 단위로 포함적-OR한다. 입력 비트 중 하나라도 1이면 결과 비트는 1이다. 둘 다 0이면 0이다.

| A   | memory | result |
| --- | ------ | ------ |
| 0   | 0      | 0      |
| 0   | 1      | 1      |
| 1   | 0      | 1      |
| 1   | 1      | 1      |

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $09    | 2      | 2                      |
| Zero Page     | $05    | 2      | 3                      |
| Zero Page,X   | $15    | 2      | 4                      |
| Absolute      | $0D    | 3      | 4                      |
| Absolute,X    | $1D    | 3      | 4 (페이지 크로싱 시 5) |
| Absolute,Y    | $19    | 3      | 4 (페이지 크로싱 시 5) |
| (Indirect,X)  | $01    | 2      | 6                      |
| (Indirect),Y  | $11    | 2      | 5 (페이지 크로싱 시 6) |

참고: AND, EOR

---

### PHA - A 푸시 (Push A)

```
($0100 + SP) = A
SP = SP - 1
```

PHA는 A의 값을 현재 스택 위치에 저장하고 스택 포인터를 감소시킨다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $48    | 1      | 3      |

참고: PLA

---

### PHP - 프로세서 상태 푸시 (Push Processor Status)

```
($0100 + SP) = NV11DIZC
SP = SP - 1
```

PHP는 6개의 상태 플래그와 B 플래그를 포함하는 바이트를 스택에 저장하고 스택 포인터를 감소시킨다. B 플래그와 여분 비트는 둘 다 1로 푸시된다. 비트 순서는 NV1BDIZC (상위에서 하위).

| 플래그       | 새 값    | 비고                                                                                         |
| ------------ | -------- | -------------------------------------------------------------------------------------------- |
| B - 브레이크 | 1로 푸시 | 이 플래그는 스택에 푸시되는 플래그 바이트에만 존재하며, CPU의 실제 상태로는 존재하지 않는다. |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $08    | 1      | 3      |

참고: PLP

---

### PLA - A 풀 (Pull A)

```
SP = SP + 1
A = ($0100 + SP)
```

PLA는 스택 포인터를 증가시키고 해당 스택 위치의 값을 A에 로드한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $68    | 1      | 4      |

참고: PHA

---

### PLP - 프로세서 상태 풀 (Pull Processor Status)

```
SP = SP + 1
NVxxDIZC = ($0100 + SP)
```

PLP는 스택 포인터를 증가시키고 해당 스택 위치의 값을 6개의 상태 플래그에 로드한다. 비트 순서는 NVxxDIZC (상위에서 하위). B 플래그와 여분 비트는 무시된다. I 변경 효과는 CLI, SEI와 마찬가지로 **1 명령어 지연**된다는 점에 유의한다. 이는 플래그가 IRQ 폴링 후에 변경되기 때문이다.

| 플래그              | 새 값         | 비고                                     |
| ------------------- | ------------- | ---------------------------------------- |
| C - 캐리            | result 비트 0 |                                          |
| Z - 제로            | result 비트 1 |                                          |
| I - 인터럽트 비활성 | result 비트 2 | 이 플래그 변경 효과는 1 명령어 지연된다. |
| D - Decimal         | result 비트 3 |                                          |
| V - 오버플로우      | result 비트 6 |                                          |
| N - 네거티브        | result 비트 7 |                                          |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $28    | 1      | 4      |

참고: PHP

---

### ROL - 좌측 회전 (Rotate Left)

`value = value << 1 through C`, 시각적으로: `C <- [76543210] <- C`

ROL은 메모리 값 또는 누산기를 왼쪽으로 시프트하며, 각 비트의 값을 다음 비트로 옮기고 캐리 플래그를 비트 7 위와 비트 0 아래 양쪽에 있는 것처럼 취급한다. 구체적으로, 캐리의 값이 비트 0으로 들어가고, 비트 7이 캐리로 이동된다. 왼쪽으로 9번 회전하면 값과 캐리가 원래 상태로 돌아간다.

이것은 **읽기-수정-쓰기** 명령어이다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| C - 캐리     | value 비트 7  |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Accumulator   | $2A    | 1      | 2      |
| Zero Page     | $26    | 2      | 5      |
| Zero Page,X   | $36    | 2      | 6      |
| Absolute      | $2E    | 3      | 6      |
| Absolute,X    | $3E    | 3      | 7      |

참고: ROR, ASL, LSR

---

### ROR - 우측 회전 (Rotate Right)

`value = value >> 1 through C`, 시각적으로: `C -> [76543210] -> C`

ROR은 메모리 값 또는 누산기를 오른쪽으로 시프트하며, 각 비트의 값을 다음 비트로 옮기고 캐리 플래그를 비트 7 위와 비트 0 아래 양쪽에 있는 것처럼 취급한다. 구체적으로, 캐리의 값이 비트 7로 들어가고, 비트 0이 캐리로 이동된다. 오른쪽으로 9번 회전하면 값과 캐리가 원래 상태로 돌아간다.

이것은 **읽기-수정-쓰기** 명령어이다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| C - 캐리     | value 비트 0  |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Accumulator   | $6A    | 1      | 2      |
| Zero Page     | $66    | 2      | 5      |
| Zero Page,X   | $76    | 2      | 6      |
| Absolute      | $6E    | 3      | 6      |
| Absolute,X    | $7E    | 3      | 7      |

참고: ROL, ASL, LSR

---

### RTI - 인터럽트에서 복귀 (Return from Interrupt)

```
SP = SP + 1
NVxxDIZC = ($0100 + SP)
SP = SP + 1
PC low = ($0100 + SP)
SP = SP + 1
PC high = ($0100 + SP)
```

RTI는 인터럽트 핸들러에서 복귀하며, 먼저 스택에서 6개의 상태 플래그를 풀하고 그 다음 새로운 프로그램 카운터를 풀한다. 플래그 풀링은 PLP처럼 동작하되, 인터럽트 비활성 플래그 변경이 1 명령어 지연되는 대신 **즉시 적용**된다는 점이 다르다. 이것은 플래그가 명령어의 IRQ 폴링 전에 변경되기 때문이다. PC 풀링은 RTS처럼 동작하되, 반환 주소가 1바이트 전이 아닌 **다음 명령어의 정확한 주소**라는 점이 다르다.

| 플래그              | 새 값         | 비고                                  |
| ------------------- | ------------- | ------------------------------------- |
| C - 캐리            | result 비트 0 |                                       |
| Z - 제로            | result 비트 1 |                                       |
| I - 인터럽트 비활성 | result 비트 2 | RTI에서는 즉시 적용된다 (PLP와 다름). |
| D - Decimal         | result 비트 3 |                                       |
| V - 오버플로우      | result 비트 6 |                                       |
| N - 네거티브        | result 비트 7 |                                       |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $40    | 1      | 6      |

참고: BRK, PLP

---

### RTS - 서브루틴에서 복귀 (Return from Subroutine)

```
SP = SP + 1
PC low = ($0100 + SP)
SP = SP + 1
PC high = ($0100 + SP)
PC = PC + 1
```

RTS는 스택에서 주소를 프로그램 카운터로 풀하고 프로그램 카운터를 증가시킨다. 보통 함수 끝에서 해당 함수를 호출한 JSR 다음 명령어로 돌아가기 위해 사용된다. 그러나 RTS는 점프 테이블 구현에도 간혹 사용된다(RTS 트릭 참고).

주목할 점으로, 스택의 반환 주소는 다음 명령어 시작 1바이트 전을 가리킨다. 이는 RTS가 다음 명령어를 페치하기 전에 프로그램 카운터를 증가시키기 때문이다. 이것은 인터럽트에 의해 푸시되고 RTI가 사용하는 반환 주소와 다르며, 인터럽트의 반환 주소는 다음 명령어를 직접 가리킨다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $60    | 1      | 6      |

참고: JSR, JMP, RTI

---

### SBC - 캐리 포함 뺄셈 (Subtract with Carry)

`A = A - memory - (1 - C)`

SBC는 메모리 값과 캐리 플래그의 NOT을 누산기에서 뺀다. 캐리 플래그는 빌려 가기(borrow)가 발생하지 않으면 세트되어, 1바이트보다 큰 값을 빌려 가기를 전파하며 뺄 수 있게 한다. 첫 바이트를 빼기 전에 SEC로 캐리를 세트하여 알려진 상태로 만드는 것이 일반적이며, 추가 1이 빠지는 것을 방지한다. 오버플로우 플래그는 부호 있는 오버플로우 또는 언더플로우가 발생했는지를 나타낸다.

| 플래그         | 새 값                                   | 비고                                                                        |
| -------------- | --------------------------------------- | --------------------------------------------------------------------------- |
| C - 캐리       | result >= 0                             | 결과가 $00 아래로 랩어라운드되면 (부호 없는 언더플로우), 캐리가 클리어된다. |
| Z - 제로       | result == 0                             |                                                                             |
| V - 오버플로우 | (result ^ A) & ~(result ^ memory) & $80 | ADC와 유사한 부호 있는 오버플로우 감지                                      |
| N - 네거티브   | result 비트 7                           |                                                                             |

| 어드레싱 모드 | Opcode | 바이트 | 사이클                 |
| ------------- | ------ | ------ | ---------------------- |
| #Immediate    | $E9    | 2      | 2                      |
| Zero Page     | $E5    | 2      | 3                      |
| Zero Page,X   | $F5    | 2      | 4                      |
| Absolute      | $ED    | 3      | 4                      |
| Absolute,X    | $FD    | 3      | 4 (페이지 크로싱 시 5) |
| Absolute,Y    | $F9    | 3      | 4 (페이지 크로싱 시 5) |
| (Indirect,X)  | $E1    | 2      | 6                      |
| (Indirect),Y  | $F1    | 2      | 5 (페이지 크로싱 시 6) |

참고: ADC, SEC

---

### SEC - 캐리 세트 (Set Carry)

`C = 1`

SEC는 캐리 플래그를 세트한다. 특히 SBC로 값의 하위 바이트를 빼기 전에 추가 1이 빠지는 것을 방지하기 위해 수행된다.

| 플래그   | 새 값 |
| -------- | ----- |
| C - 캐리 | 1     |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $38    | 1      | 2      |

참고: CLC

---

### SED - 십진 모드 세트 (Set Decimal)

`D = 1`

SED는 십진 플래그를 세트한다. 십진 플래그는 보통 BCD 모드를 활성화하는지를 제어하지만, 이 모드는 NES의 2A03 CPU에서 영구적으로 비활성화되어 있다. 그러나 플래그 자체는 여전히 동작하며 상태를 저장하는 데 사용할 수 있다.

| 플래그      | 새 값 |
| ----------- | ----- |
| D - Decimal | 1     |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $F8    | 1      | 2      |

참고: CLD

---

### SEI - 인터럽트 비활성 세트 (Set Interrupt Disable)

`I = 1`

SEI는 인터럽트 비활성 플래그를 세트하여, CPU가 하드웨어 IRQ를 처리하지 못하게 한다. 이 플래그 변경 효과는 **1 명령어 지연**된다. 플래그가 IRQ 폴링 후에 변경되기 때문에, 이전에 플래그가 0이었다면 이 명령어와 다음 명령어 사이에 IRQ가 서비스될 수 있다.

| 플래그              | 새 값 | 비고                                     |
| ------------------- | ----- | ---------------------------------------- |
| I - 인터럽트 비활성 | 1     | 이 플래그 변경 효과는 1 명령어 지연된다. |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $78    | 1      | 2      |

참고: CLI

---

### STA - A 저장 (Store A)

`memory = A`

STA는 누산기의 값을 메모리에 저장한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Zero Page     | $85    | 2      | 3      |
| Zero Page,X   | $95    | 2      | 4      |
| Absolute      | $8D    | 3      | 4      |
| Absolute,X    | $9D    | 3      | 5      |
| Absolute,Y    | $99    | 3      | 5      |
| (Indirect,X)  | $81    | 2      | 6      |
| (Indirect),Y  | $91    | 2      | 6      |

참고: LDA

---

### STX - X 저장 (Store X)

`memory = X`

STX는 X 레지스터의 값을 메모리에 저장한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Zero Page     | $86    | 2      | 3      |
| Zero Page,Y   | $96    | 2      | 4      |
| Absolute      | $8E    | 3      | 4      |

참고: LDX

---

### STY - Y 저장 (Store Y)

`memory = Y`

STY는 Y 레지스터의 값을 메모리에 저장한다.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Zero Page     | $84    | 2      | 3      |
| Zero Page,X   | $94    | 2      | 4      |
| Absolute      | $8C    | 3      | 4      |

참고: LDY

---

### TAX - A를 X로 전송 (Transfer A to X)

`X = A`

TAX는 누산기의 값을 X 레지스터에 복사한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $AA    | 1      | 2      |

참고: TXA

---

### TAY - A를 Y로 전송 (Transfer A to Y)

`Y = A`

TAY는 누산기의 값을 Y 레지스터에 복사한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $A8    | 1      | 2      |

참고: TYA

---

### TSX - SP를 X로 전송 (Transfer Stack Pointer to X)

`X = SP`

TSX는 스택 포인터의 값을 X 레지스터에 복사한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $BA    | 1      | 2      |

참고: TXS

---

### TXA - X를 A로 전송 (Transfer X to A)

`A = X`

TXA는 X 레지스터의 값을 누산기에 복사한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $8A    | 1      | 2      |

참고: TAX

---

### TXS - X를 SP로 전송 (Transfer X to Stack Pointer)

`SP = X`

TXS는 X 레지스터의 값을 스택 포인터에 복사한다. 주목할 점으로, 이 명령어는 **플래그에 영향을 미치지 않는다**.

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $9A    | 1      | 2      |

참고: TSX

---

### TYA - Y를 A로 전송 (Transfer Y to A)

`A = Y`

TYA는 Y 레지스터의 값을 누산기에 복사한다.

| 플래그       | 새 값         |
| ------------ | ------------- |
| Z - 제로     | result == 0   |
| N - 네거티브 | result 비트 7 |

| 어드레싱 모드 | Opcode | 바이트 | 사이클 |
| ------------- | ------ | ------ | ------ |
| Implied       | $98    | 1      | 2      |

참고: TAY

---

## 각주

\* 분기 명령어의 사이클 수: 분기를 취하지 않으면 2사이클, 분기를 취하면 3사이클, 분기 대상이 다른 페이지에 있으면 4사이클.

---

## 에뮬레이터 구현 시 주요 참고사항

- **STA, STX, STY (쓰기 명령어)**: 페이지 크로싱에 의한 추가 사이클이 **없다**. Absolute,X/Y 등에서 항상 고정 사이클. 읽기 명령어만 "+1 if page crossed" 해당.
- **읽기-수정-쓰기 명령어 (ASL, LSR, ROL, ROR, INC, DEC)**: Absolute,X에서 항상 7사이클 (페이지 크로싱 여부 무관). 또한 수정된 값 쓰기 전에 원래 값을 먼저 쓰는 동작이 있어, 하드웨어 레지스터 대상 시 사이드 이펙트 주의.
- **B 플래그**: CPU 내부에 물리적으로 존재하지 않는다. PHP와 BRK가 스택에 푸시하는 플래그 바이트에서만 나타남. PHP/BRK는 1, IRQ/NMI는 0으로 설정.
- **I 플래그 지연**: CLI, SEI, PLP에 의한 I 플래그 변경은 1 명령어 지연된다. RTI에서만 즉시 적용.
- **JSR/RTS 반환 주소**: JSR은 PC+2 (다음 명령어의 1바이트 전)를 푸시. RTS는 풀 후 PC+1. RTI는 풀한 주소를 그대로 사용.
- **JMP Indirect 버그**: $xxFF 주소에서 간접 점프 시 페이지 래핑 버그 재현 필수.
- **NES 2A03 특수사항**: BCD 모드(십진 모드) 비활성 — ADC/SBC에서 D 플래그 무시. SO(Set Overflow) 핀 없음 — 외부에서 V 플래그 세트 불가.
